{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Emitter = void 0;\n\nvar vector_1 = require(\"../components/vector\");\n\nvar settings_1 = require(\"../settings\");\n\nvar variation_1 = require(\"../systems/variation\");\n\nvar config_1 = require(\"../util/config\");\n\nvar options_1 = require(\"./options\");\n\nvar particle_1 = require(\"./particle\");\n/**\r\n * Represents an emitter that is responsible for spawning and updating particles.\r\n *\r\n * Particles themselves are just data-holders, with the system acting upon them and\r\n * modifying them. The modifications are done mainly via modules, that use the\r\n * particle's data together with some function to apply temporal transitions.\r\n *\r\n * @see Particle\r\n * @see ParticleModifierModule\r\n */\n\n\nvar Emitter =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new emitter, using default options.\r\n   */\n  function Emitter(options) {\n    /**\r\n     * The particles currently contained within the system.\r\n     */\n    this.particles = [];\n    this.currentLoop = 0; // The current loop index.\n\n    this.durationTimer = 0; // Measures the current runtime duration, to allow loops to reset.\n\n    this.emissionTimer = 0; // Measures the current emission timer, to allow spawning particles in intervals.\n\n    this.attemptedBurstIndices = []; // The indices of the particle bursts that were attempted this loop.\n\n    this.options = config_1.overrideDefaults(options_1.getDefaultEmitterOptions(), options === null || options === void 0 ? void 0 : options.emitterOptions);\n    this.emission = config_1.overrideDefaults(options_1.getDefaultEmissionOptions(), options === null || options === void 0 ? void 0 : options.emissionOptions);\n    this.renderer = config_1.overrideDefaults(options_1.getDefaultRendererOptions(), options === null || options === void 0 ? void 0 : options.rendererOptions);\n  }\n\n  Object.defineProperty(Emitter.prototype, \"isExpired\", {\n    /**\r\n     * Checks if the emitter is already expired and can be removed.\r\n     * Expired emitters do not emit new particles.\r\n     */\n    get: function () {\n      return this.options.loops >= 0 && this.currentLoop >= this.options.loops;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Emitter.prototype, \"canRemove\", {\n    /**\r\n     * Checks if the emitter can safely be removed.\r\n     * This is true if no more particles are active.\r\n     */\n    get: function () {\n      return this.particles.length === 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Clears all particles inside the emitter.\r\n   *\r\n   * @returns The number of cleared particles.\r\n   */\n\n  Emitter.prototype.clearParticles = function () {\n    return this.particles.splice(0).length;\n  };\n  /**\r\n   * Processes a tick of the emitter, using the elapsed time.\r\n   *\r\n   * @remarks\r\n   * This handles a few things, namely:\r\n   * - Incrementing the duration timer and potentially incrementing the loop.\r\n   * - Handling particle bursts & emissions.\r\n   * - Despawning particles conditionally.\r\n   *\r\n   * @param delta The time, in seconds, passed since the last tick.\r\n   */\n\n\n  Emitter.prototype.tick = function (delta) {\n    if (!this.isExpired) {\n      this.durationTimer += delta;\n\n      if (this.durationTimer >= this.options.duration) {\n        this.currentLoop++; // To start a new loop, the duration timer and attempted bursts are reset.\n\n        this.durationTimer = 0;\n        this.attemptedBurstIndices = [];\n      } // We need to check the expiry again, in case the added loop or duration changed something.\n\n\n      if (!this.isExpired) {\n        // Iterate over the bursts, attempting to execute them if the time is ready.\n        var burstIndex = 0;\n\n        for (var _i = 0, _a = this.emission.bursts; _i < _a.length; _i++) {\n          var burst = _a[_i];\n\n          if (burst.time <= this.durationTimer) {\n            // Has the burst already been attempted? If not ...\n            if (!this.attemptedBurstIndices.includes(burstIndex)) {\n              // Perform the burst, emitting a variable amount of particles.\n              var count = variation_1.evaluateVariation(burst.count);\n\n              for (var i = 0; i < count; i++) {\n                this.emitParticle();\n              } // Mark the burst as attempted.\n\n\n              this.attemptedBurstIndices.push(burstIndex);\n            }\n          }\n\n          burstIndex++;\n        } // Handle the 'emission over time'. By using a while-loop instead of a simple\n        // if-condition, we take high deltas into account, and ensure that the correct\n        // number of particles will consistently be emitted.\n\n\n        this.emissionTimer += delta;\n        var delay = 1 / this.emission.rate;\n\n        while (this.emissionTimer > delay) {\n          this.emissionTimer -= delay;\n          this.emitParticle();\n        }\n      }\n    }\n\n    var _loop_1 = function (i) {\n      var particle = this_1.particles[i];\n      this_1.tickParticle(particle, delta); // Particles should be despawned (i.e. removed from the collection) if any of\n      // the despawning rules apply to them.\n\n      if (this_1.options.despawningRules.some(function (rule) {\n        return rule(particle);\n      })) {\n        this_1.particles.splice(i, 1);\n      }\n    };\n\n    var this_1 = this;\n\n    for (var i = this.particles.length - 1; i >= 0; i--) {\n      _loop_1(i);\n    }\n  };\n  /**\r\n   * Performs an internal tick for the particle.\r\n   *\r\n   * @remarks\r\n   * This method controls the particle's lifetime, location and velocity, according\r\n   * to the elapsed delta and the configuration. Additionally, each of the emitter's\r\n   * modules is applied to the particle.\r\n   *\r\n   * @param particle The particle to apply the tick for.\r\n   * @param delta The time, in seconds, passed since the last tick.\r\n   */\n\n\n  Emitter.prototype.tickParticle = function (particle, delta) {\n    particle.lifetime -= delta;\n\n    if (this.options.useGravity) {\n      // Apply gravitational acceleration to the particle.\n      particle.velocity = particle.velocity.add(vector_1.Vector.up.scale(settings_1.settings.gravity * delta));\n    } // Apply the particle's velocity to its location.\n\n\n    particle.location = particle.location.add(particle.velocity.scale(delta)); // Apply the modules to the particle.\n\n    for (var _i = 0, _a = this.options.modules; _i < _a.length; _i++) {\n      var moduleFunction = _a[_i];\n      moduleFunction(particle);\n    }\n  };\n  /**\r\n   * Emits a particle using the registered settings.\r\n   * Also may despawn a particle if the maximum number of particles is exceeded.\r\n   */\n\n\n  Emitter.prototype.emitParticle = function () {\n    var particle = new particle_1.Particle({\n      location: this.emission.sourceSampler(),\n      lifetime: variation_1.evaluateVariation(this.emission.initialLifetime),\n      velocity: vector_1.Vector.from2dAngle(variation_1.evaluateVariation(this.emission.angle)).scale(variation_1.evaluateVariation(this.emission.initialSpeed)),\n      size: variation_1.evaluateVariation(this.emission.initialSize),\n      rotation: variation_1.evaluateVariation(this.emission.initialRotation),\n      color: variation_1.evaluateVariation(this.emission.initialColor)\n    });\n    this.particles.push(particle); // Ensure that no more particles than 'maxParticles' can exist.\n\n    if (this.particles.length > this.options.maxParticles) {\n      this.particles.shift();\n    }\n\n    return particle;\n  };\n\n  return Emitter;\n}();\n\nexports.Emitter = Emitter;","map":{"version":3,"mappings":"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","names":["options","config_1","options_1","emitterOptions","emission","emissionOptions","renderer","rendererOptions","Object","Emitter","loops","currentLoop","particles","length","splice","delta","isExpired","durationTimer","duration","attemptedBurstIndices","burstIndex","bursts","_i","burst","time","includes","count","variation_1","i","emitParticle","push","emissionTimer","delay","rate","particle","this_1","tickParticle","despawningRules","some","rule","lifetime","useGravity","velocity","add","vector_1","up","scale","settings_1","gravity","location","modules","moduleFunction","particle_1","sourceSampler","initialLifetime","from2dAngle","angle","initialSpeed","size","initialSize","rotation","initialRotation","color","initialColor","maxParticles","shift","exports"],"sources":["../../src/particles/emitter.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}