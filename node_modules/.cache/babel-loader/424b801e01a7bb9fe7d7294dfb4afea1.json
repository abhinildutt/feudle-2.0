{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Spline = void 0;\n\nvar math_1 = require(\"../systems/math\");\n/**\n * Represents a spline that can be used to continueously evaluate a function\n * between keys. The base implementation is kept generic, so the functionality\n * can easily be implemented for similar constructs, such as gradients.\n */\n\n\nvar Spline =\n/** @class */\nfunction () {\n  /**\n   * Creates a new spline instance, using the specified keys.\n   * Note that you have to pass at least one key.\n   */\n  function Spline() {\n    var keys = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      keys[_i] = arguments[_i];\n    }\n\n    if (keys.length === 0) {\n      throw new Error(\"Splines require at least one key.\");\n    }\n\n    if (Array.isArray(keys[0])) {\n      throw new Error(\"You are trying to pass an array to the spline constructor, which is not supported. \" + \"Try to spread the array into the constructor instead.\");\n    }\n\n    this.keys = keys;\n  }\n  /**\n   * Evaluates the spline at the given time.\n   */\n\n\n  Spline.prototype.evaluate = function (time) {\n    if (this.keys.length === 0) {\n      throw new Error(\"Attempt to evaluate a spline with no keys.\");\n    }\n\n    if (this.keys.length === 1) {\n      // The spline only contains one key, therefore is constant.\n      return this.keys[0].value;\n    } // Sort the keys and figure out the first key above the passed time.\n\n\n    var ascendingKeys = this.keys.sort(function (a, b) {\n      return a.time - b.time;\n    });\n    var upperKeyIndex = ascendingKeys.findIndex(function (g) {\n      return g.time > time;\n    }); // If the found index is either 0 or -1, the specified time falls out\n    // of the range of the supplied keys. In that case, the value of the\n    // nearest applicant key is returned.\n\n    if (upperKeyIndex === 0) {\n      return ascendingKeys[0].value;\n    }\n\n    if (upperKeyIndex === -1) {\n      return ascendingKeys[ascendingKeys.length - 1].value;\n    } // Otherwise, find the bounding keys, and extrapolate the time between\n    // the two. This is then used to interpolate between the two keys,\n    // using the provided implementation.\n\n\n    var lowerKey = ascendingKeys[upperKeyIndex - 1];\n    var upperKey = ascendingKeys[upperKeyIndex];\n    var containedTime = math_1.invlerp(lowerKey.time, upperKey.time, time);\n    return this.interpolate(lowerKey.value, upperKey.value, containedTime);\n  };\n\n  return Spline;\n}();\n\nexports.Spline = Spline;","map":{"version":3,"mappings":";;;;;;;AAAA;AAgBA;;;;;;;AAKA;AAAA;AAAA;EAMI;;;;EAIA;IAAY;;SAAA,yCAAuB;MAAvBA;;;IACR,IAAIA,IAAI,CAACC,MAAL,KAAgB,CAApB,EAAuB;MACnB,MAAM,IAAIC,KAAJ,CAAU,mCAAV,CAAN;IACH;;IACD,IAAIC,KAAK,CAACC,OAAN,CAAcJ,IAAI,CAAC,CAAD,CAAlB,CAAJ,EAA4B;MACxB,MAAM,IAAIE,KAAJ,CACF,wFACI,uDAFF,CAAN;IAIH;;IACD,KAAKF,IAAL,GAAYA,IAAZ;EACH;EAED;;;;;EAGOK,4BAAP,UAAgBC,IAAhB,EAA4B;IACxB,IAAI,KAAKN,IAAL,CAAUC,MAAV,KAAqB,CAAzB,EAA4B;MACxB,MAAM,IAAIC,KAAJ,CAAU,4CAAV,CAAN;IACH;;IAED,IAAI,KAAKF,IAAL,CAAUC,MAAV,KAAqB,CAAzB,EAA4B;MACxB;MACA,OAAO,KAAKD,IAAL,CAAU,CAAV,EAAaO,KAApB;IACH,CARuB,CAUxB;;;IACA,IAAMC,aAAa,GAAG,KAAKR,IAAL,CAAUS,IAAV,CAAe,UAACC,CAAD,EAAIC,CAAJ,EAAK;MAAK,QAAC,CAACL,IAAF,GAASK,CAAC,CAACL,IAAX;IAAe,CAAxC,CAAtB;IACA,IAAMM,aAAa,GAAGJ,aAAa,CAACK,SAAd,CAAwB,UAACC,CAAD,EAAE;MAAK,QAAC,CAACR,IAAF,GAASA,IAAT;IAAa,CAA5C,CAAtB,CAZwB,CAcxB;IACA;IACA;;IACA,IAAIM,aAAa,KAAK,CAAtB,EAAyB;MACrB,OAAOJ,aAAa,CAAC,CAAD,CAAb,CAAiBD,KAAxB;IACH;;IACD,IAAIK,aAAa,KAAK,CAAC,CAAvB,EAA0B;MACtB,OAAOJ,aAAa,CAACA,aAAa,CAACP,MAAd,GAAuB,CAAxB,CAAb,CAAwCM,KAA/C;IACH,CAtBuB,CAwBxB;IACA;IACA;;;IACA,IAAMQ,QAAQ,GAAGP,aAAa,CAACI,aAAa,GAAG,CAAjB,CAA9B;IACA,IAAMI,QAAQ,GAAGR,aAAa,CAACI,aAAD,CAA9B;IACA,IAAMK,aAAa,GAAGC,eAAQH,QAAQ,CAACT,IAAjB,EAAuBU,QAAQ,CAACV,IAAhC,EAAsCA,IAAtC,CAAtB;IAEA,OAAO,KAAKa,WAAL,CAAiBJ,QAAQ,CAACR,KAA1B,EAAiCS,QAAQ,CAACT,KAA1C,EAAiDU,aAAjD,CAAP;EACH,CAhCM;;EAsCX;AAAC,CAhED;;AAAsBG","names":["keys","length","Error","Array","isArray","Spline","time","value","ascendingKeys","sort","a","b","upperKeyIndex","findIndex","g","lowerKey","upperKey","containedTime","math_1","interpolate","exports"],"sources":["../../src/components/spline.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}